import isPlainObject from 'lodash/isPlainObject'
import $$observable from 'symbol-observable'

/**
 * 这些是由Redux保留的私有的ActionTypes
 * 对于任何未知的ActionTypes，您必须返回当前状态。
 * 如果当前状态未定义，则必须返回初始状态。
 * 不要直接在代码中引用这些action types
 */
export const ActionTypes = {
  INIT: '@@redux/INIT'
}
/**
 * 创建一个含有状态树的Redux store。
 * 改变store里的数据的唯一方法是调用`dispatch（）`。
 * 应用中应该只有一个store。指定有多不同状态树来响应action，您可以组合几个reducer，
 * 通过使用`combineReducers`，将其转换为单个reducer功能。
 *
 * @param {Function} reducer一个函数，返回给定的下一个状态树，指定当前状态树和要处理的动作。
 *
 * @param {any} [preloadedState] 初始状态。您可以选择指定它
 * 从通用应用程序中的服务器中提取状态，或者恢复以前序列化的用户会话。
 * 如果使用`combineReducers`生成根reducer功能，则必须如此与“combineReducers”键形状相同的对象。
 *
 * @param {Function} [enhancer] store增强器。您可以选择指定它通过第三方库增强store，如中间件，
 * 时间旅行，持久性等。Redux附带的唯一store增强器是`applyMiddleware（）`。
 * @returns {Store}一个Redux store，可以让你读取状态，发送操作
 * 并订阅更改。
 */
/**
 * reducer (Function): 接收两个参数，分别是当前的 state 树和要处理的 action，返回新的 state 树。
 * [preloadedState] (any): 初始时的 state，可用于同构应用
 * enhancer (Function): Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。
 * **/
export default function createStore(reducer, preloadedState, enhancer) {
  /**
   * 如果preloadedState为函数且enhancer === 'undefined'，则替换preloadedState和enhancer的值
   * **/
  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState
    preloadedState = undefined
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.')
    }
    /**
     * 产生一个增强的createStore
     * @param createStore
     * @param reducer
     * @param preloadedState
     * **/
    return enhancer(createStore)(reducer, preloadedState)
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.')
  }
  //初始化
  let currentReducer = reducer
  let currentState = preloadedState
  let currentListeners = []
  let nextListeners = currentListeners
  let isDispatching = false

  /**
   * ensureCanMutateNextListeners
   * 拷贝currentListeners一份，赋值给currentListeners
   * **/
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice()
    }
  }

  /**
   * getState 函数
   * 获取当前state树的值
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState
  }

  /**
   * 添加监听器。它将在任何时候被调用，
   * 并且state树的某些部分可能已经改变。那么你可以在callback中调用`getState（）`来读取当前状态树。
   * 
   * 您可以使用以下命令从监听器中调用dispatch（）
   * 注意:
   *
   * 1. subscriptions 在每个dispatch（）调用之前被快照。.
   * 如果您在调用listener时subscriptions或者unsubscriptions, 这对当前流程的dispatch()没有任何影响，
   * 但是，下一次的dispatch（），无论是否嵌套，都会使用最近的订阅列表快照。就是订阅／取消订阅操作只会在下一次dispatch生效
   * 
   * 2. The listener 不应该监听到所有的state变化，如在listener被调用，state可能在嵌套`dispatch（）`多次更新
   * 但是保证所有的subscribers在dispatch()调用前被注册将会是最新的状态在这次循环结束时
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} return一个函数，来注销掉该listener器
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.')
    }

    let isSubscribed = true

    ensureCanMutateNextListeners()
    nextListeners.push(listener)

    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      isSubscribed = false

      ensureCanMutateNextListeners()
      const index = nextListeners.indexOf(listener)
      nextListeners.splice(index, 1)
    }
  }
  /*Dispatches an action。这是触发state变化的唯一途径。
     *
     *用于创建store的`reducer`函数将被调用，通过当前状态树和给定的“action”。它的返回值会
     *被认为是store树的下一个状态，以及listener将被通知。
     *
     *基本实现仅支持普通对象action。
     *如果你想发送一个Promise，一个Observable，一个thunk或者其他的东西，你需要
     *将您的store里创建功能包装到相应的中间件中。对于
     *例如，请参阅`redux-thunk`包的文档。即便是中间件最终将使用这种方法派发简单的对象操作。
     *
     * @param {Object} action 表示“变更内容”的普通对象。它是
     *保持动作可序列化的好主意，以便您可以录制和重放用户会话，或使用时间旅行`redux-devtools`。
     *一个行动必须有一个'type`属性，它可能不是`undefined`。
     *用常量定义动作类型是个好主意
     *
     * @returns {Object}为了方便起见，您分派了相同的操作对象。
     *
     *请注意，如果您使用自定义中间件，它可能会将`dispatch（）`包装为返回其他东西（例如， a Promise you can await)）。
     */
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(
        'Actions must be plain objects. ' +
        'Use custom middleware for async actions.'
      )
    }

    if (typeof action.type === 'undefined') {
      throw new Error(
        'Actions may not have an undefined "type" property. ' +
        'Have you misspelled a constant?'
      )
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.')
    }

    try {
      isDispatching = true
      //执行对应的reducer
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }
    //这里决定着订阅还是取消订阅都是在下一次dispatch才能生效
    const listeners = currentListeners = nextListeners
    for (let i = 0; i < listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }

    return action
  }

  /**
     *替换store当前使用的reducer来计算state
     *
     *如果你的应用实现代码拆分并且你想要，你可能需要这个
     *动态加载一些reducer。 如果你也可能需要这个为Redux实现热重新加载机制。
     *
     * @param {Function} nextReducer 用来代替store的reducer。
     * @returns {void}
     */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.')
    }

    currentReducer = nextReducer
    //重新执行一次初始化
    dispatch({ type: ActionTypes.INIT })
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    const outerSubscribe = subscribe
    return {
      /**
         *最小可观察订阅方法。
         * @param {Object} observer 可以用作观察者的任何对象。观察者对象应该有一个`next`方法。
         * @returns {subscription} 具有`unsubscribe`方法的对象 用于取消订阅商店中的观察记录，并进一步阻止可观测值的排放。
        */
      subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.')
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState())
          }
        }

        observeState()
        const unsubscribe = outerSubscribe(observeState)
        return { unsubscribe }
      },

      [$$observable]() {
        return this
      }
    }
  }

  //当一个商店被创建时，一个“INIT”动作被调度，以便每一个reducer返回它们的初始状态。 这有效地填充初始状态树。
  dispatch({ type: ActionTypes.INIT })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}
