import hoistStatics from 'hoist-non-react-statics'
import invariant from 'invariant'
import { Component, createElement } from 'react'

import Subscription from '../utils/Subscription'
import { storeShape, subscriptionShape } from '../utils/PropTypes'

let hotReloadingVersion = 0
const dummyState = {}
function noop() { }
function makeSelectorStateful(sourceSelector, store) {
  // 将选择器包裹在一个跟踪其运行结果的对象中。
  const selector = {
    run: function runComponentSelector(props) {
      try {
        //调用sourceSelector，返回合并的props；
        const nextProps = sourceSelector(store.getState(), props)
        //只有不同才决定刷新页面
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true
          selector.props = nextProps
          selector.error = null
        }
      } catch (error) {
        selector.shouldComponentUpdate = true
        selector.error = error
      }
    }
  }

  return selector
}

export default function connectAdvanced(
  /***
   * selectorFactory是一个负责返回一个根据state,props,and dispatch计算出新的props选择器函数的函数。
   * 例如：
   *    export default connectAdvanced((dispatch, options) => (state, props) => ({
         thing: state.things[props.thingId],
         saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
       }))(YourComponent)
   * dispatch被提供给factory,因此selectorFactories可以将actionCreators绑定到选择器外部作为优化。
   * 传递给connectAdvanced的选项作为第二个参数传递给selectorFactory以及displayName和WrappedComponent。 
   * 请注意，selectorFactory负责入站和出站props的所有缓存/记忆。 
   * 不要在调用选择器之间没有记忆结果的情况下直接使用connectAdvanced，否则连接组件将在每个状态或道具变化时重新渲染。
  */
  selectorFactory,
  // options object:
  {
    // 用于从包装组件的displayName中计算Connect的displayName的函数。
    // 可能会被包裹函数的值覆盖，比如connect()
    getDisplayName = name => `ConnectAdvanced(${name})`,

    // shown in error messages
    // probably overridden by wrapper functions such as connect()
    methodName = 'connectAdvanced',

    //如果已定义，则传递给包装元素的属性名称将指示要呈现的调用渲染的数量。 用于在react devtools中观看不必要的重新渲染。
    renderCountProp = undefined,

    // determines whether this HOC subscribes to store changes
    //确定此HOC是否订阅 store changes
    shouldHandleStateChanges = true,

    // the key of props/context to get the store
    storeKey = 'store',

    // if true, the wrapped element is exposed by this HOC via the getWrappedInstance() function.
    //也就是说组件的ref会指向被HOC包装返回的组件，而非传入高阶组件，如果withRef = true的话
    //则包裹元素通过getWrappedInstance（）函数由此HOC公开。
    withRef = false,

    // additional options are passed through to the selectorFactory
    ...connectOptions
  } = {}
) {
  const subscriptionKey = storeKey + 'Subscription'
  const version = hotReloadingVersion++

  const contextTypes = {
    [storeKey]: storeShape,
    [subscriptionKey]: subscriptionShape,
  }
  //要使用context传递数据必须添加自组件的的childContextTypes
  const childContextTypes = {
    [subscriptionKey]: subscriptionShape,
  }
  //最后一层触发是用connect(WrappedComponent),可以使用@connect()
  return function wrapWithConnect(WrappedComponent) {
    invariant(
      typeof WrappedComponent == 'function',
      `You must pass a component to the function returned by ` +
      `${methodName}. Instead received ${JSON.stringify(WrappedComponent)}`
    )

    const wrappedComponentName = WrappedComponent.displayName
      || WrappedComponent.name
      || 'Component'
    //用于从包装组件的displayName中计算Connect的displayName的函数。
    const displayName = getDisplayName(wrappedComponentName)

    const selectorFactoryOptions = {
      ...connectOptions,
      getDisplayName,
      methodName,
      renderCountProp,
      shouldHandleStateChanges,
      storeKey,
      withRef,
      displayName,
      wrappedComponentName,
      WrappedComponent
    }

    class Connect extends Component {
      constructor(props, context) {
        super(props, context)

        this.version = version
        this.state = {}
        this.renderCount = 0
        this.store = props[storeKey] || context[storeKey]
        this.propsMode = Boolean(props[storeKey])//默认为false
        this.setWrappedInstance = this.setWrappedInstance.bind(this)

        invariant(this.store,
          `Could not find "${storeKey}" in either the context or props of ` +
          `"${displayName}". Either wrap the root component in a <Provider>, ` +
          `or explicitly pass "${storeKey}" as a prop to "${displayName}".`
        )
        //初始化store数据
        this.initSelector()
        this.initSubscription()
      }

      getChildContext() {
        /*
        如果此组件从props收到store，则其subscription应该对从context接收store+subscription的任何后代都是透明的; 
        它传递给它的订阅。 否则，它会影响父订阅，这使得Connect可以控制通知的顺序从上到下
        */
        const subscription = this.propsMode ? null : this.subscription
        return { [subscriptionKey]: subscription || this.context[subscriptionKey] }
      }

      componentDidMount() {
        if (!shouldHandleStateChanges) return
        /*
        componentWillMount在服务器端呈现期间触发，但componentDidMount和componentWillUnmount不会。 
        正因为如此，trySubscribe发生在... didMount期间。 
        否则，在SSR期间不会发生取消订阅，导致内存泄漏。 
        为了处理子组件可能通过派发componentWillMount中的动作触发状态改变的情况，
        我们必须重新运行select并且可能re-render。
        WillMount -> sub-WillMount -> sub-DidMount -> DidMount
        */
        this.subscription.trySubscribe()
        this.selector.run(this.props)
        if (this.selector.shouldComponentUpdate) this.forceUpdate()
      }

      componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps)
      }

      shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate
      }

      componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe()
        this.subscription = null
        this.notifyNestedSubs = noop
        this.store = null
        this.selector.run = noop
        this.selector.shouldComponentUpdate = false
      }

      getWrappedInstance() {
        invariant(withRef,
          `To access the wrapped instance, you need to specify ` +
          `{ withRef: true } in the options argument of the ${methodName}() call.`
        )
        return this.wrappedInstance
      }

      setWrappedInstance(ref) {
        this.wrappedInstance = ref
      }

      initSelector() {
        //根据pure的bool值，返回一个当state change的时候，刷新页面规则的函数，
        //该函数被调用后会输出一个合并过的props，
        //所有的redux的state都在selectorFactory的闭包里面做为私有数据--缓存
        const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)
        this.selector = makeSelectorStateful(sourceSelector, this.store)
        //合并props
        this.selector.run(this.props)
      }

      initSubscription() {
        if (!shouldHandleStateChanges) return
        //parentSub的来源应该与store的来源相匹配：props与context。 
        // 通过props连接到store的组件不应该使用从context订阅，反之亦然。\
        const parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey]
        //parentSub默认值为null
        this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this))

        /*
        `notifyNestedSubs`被复制来处理当组件在通知循环中被卸载的情况，然后`this.subscription`将被置为null,
        拷贝this中的方法，然后在组件卸载中用一个noop函数代替它，来避免每次改变的额外的null检查
        如果在通知循环中，取消订阅，使得Subscription的listeners逻辑改为不调用listener可能会避免这种情况
        */
        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription)
      }

      onStateChange() {
        //合成state、props，返回nextProps
        this.selector.run(this.props)

        if (!this.selector.shouldComponentUpdate) {
          this.notifyNestedSubs()
        } else {
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate
          this.setState(dummyState)
        }
      }

      notifyNestedSubsOnComponentDidUpdate() {
        /*
        `onStateChange`确定它需要通知嵌套的subs时``componentDidUpdate`有条件地实现。 
        一旦被调用，它就会自我实现，直到进一步发生状态变化。 
        这样做与拥有一个每次都进行布尔检查的永久`componentDidUpdate`可以避免大部分时间的额外方法调用，
        从而导致一些性能提升。
        */
        this.componentDidUpdate = undefined
        this.notifyNestedSubs()
      }

      isSubscribed() {
        return Boolean(this.subscription) && this.subscription.isSubscribed()
      }

      addExtraProps(props) {
        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props
        /*
        创建一个浅拷贝，以便添加的字段不会泄漏到原始选择器中。 这对'ref'尤其重要，因为这是对组件实例的引用。 
        一个单身的memoized选择器然后将持有对实例的引用，防止实例被垃圾收集，这将是不好的
        */
        const withExtras = { ...props }
        //把WrappedComponent绑定到this.wrappedInstance,并暴露getWrappedInstance来调用它
        if (withRef) withExtras.ref = this.setWrappedInstance
        //如果renderCountProp为true，暴露渲染次数，用于做优化
        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++
        //
        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription
        return withExtras
      }

      render() {
        const selector = this.selector
        selector.shouldComponentUpdate = false

        if (selector.error) {
          throw selector.error
        } else {
          return createElement(WrappedComponent, this.addExtraProps(selector.props))
        }
      }
    }

    Connect.WrappedComponent = WrappedComponent
    Connect.displayName = displayName
    Connect.childContextTypes = childContextTypes
    Connect.contextTypes = contextTypes
    Connect.propTypes = contextTypes

    if (process.env.NODE_ENV !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        // We are hot reloading!
        if (this.version !== version) {
          this.version = version
          this.initSelector()

          // If any connected descendants don't hot reload (and resubscribe in the process), their
          // listeners will be lost when we unsubscribe. Unfortunately, by copying over all
          // listeners, this does mean that the old versions of connected descendants will still be
          // notified of state changes; however, their onStateChange function is a no-op so this
          // isn't a huge deal.
          let oldListeners = [];

          if (this.subscription) {
            oldListeners = this.subscription.listeners.get()
            this.subscription.tryUnsubscribe()
          }
          this.initSubscription()
          if (shouldHandleStateChanges) {
            this.subscription.trySubscribe()
            oldListeners.forEach(listener => this.subscription.listeners.subscribe(listener))
          }
        }
      }
    }

    return hoistStatics(Connect, WrappedComponent)
  }
}
