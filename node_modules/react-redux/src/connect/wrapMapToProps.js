import verifyPlainObject from '../utils/verifyPlainObject'

export function wrapMapToPropsConstant(getConstant) {
  //getConstant = () => ({})
  return function initConstantSelector(dispatch, options) {
    const constant = getConstant(dispatch, options)

    function constantSelector() { return constant }
    constantSelector.dependsOnOwnProps = false 
    return constantSelector  
  }
}

/**
 * dependsOnOwnProps被createMapToPropsProxy用来确定是否将props作为参数传递给包装的mapToProps函数。
 * makePurePropsSelector也使用它来确定在props更改时是否需要调用mapToProps。
  一个表示mapToProps的信号的长度不依赖于父组件的道具。
  假定零长度意味着mapToProps通过参数或...参数获取参数，因此不准确报告其长度。
**/
export function getDependsOnOwnProps(mapToProps) {
  return (mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined)
    ? Boolean(mapToProps.dependsOnOwnProps)
    : mapToProps.length !== 1
}   
/**
 * 使用'whenMapStateToPropsIsFunction'和'whenMapDispatchToPropsIsFunction'时，
  这个函数将mapToProps包装在一个代理函数中，它执行几件事情：
   *检测mapToProps函数是否被调用取决于被selectorFactory使用，来决定是否应该重新调用props更改的props。
    
   *在第一次调用时，如果返回另一个函数，则处理mapToProps并对其进行处理
     新函数作为后续调用的mapToProps。
    
   *在第一次调用时，验证第一个结果是一个普通对象，以便警告开发人员
    他们的mapToProps函数没有返回有效结果的
 * **/
export function wrapMapToPropsFunc(mapToProps, methodName) {
  ///mapToProps类似一个(state)=>{a:state.a.x,b:state.b.x},methodName = 'mapStateToProps'
  return function initProxySelector(dispatch, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps
        ? proxy.mapToProps(stateOrDispatch, ownProps)//初始化调用一次可以获取ownProps的proxy.mapToProps
        : proxy.mapToProps(stateOrDispatch)//状态改变时，不再获取ownProps
    }

    // 允许detectFactoryAndVerify获取ownProps
    proxy.dependsOnOwnProps = true

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      //代理函数proxy的mapToProps为原有的传入方法
      proxy.mapToProps = mapToProps
      //一般情况返回false
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)
      let props = proxy(stateOrDispatch, ownProps)

      if (typeof props === 'function') {
        proxy.mapToProps = props
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
        props = proxy(stateOrDispatch, ownProps)
      }

      if (process.env.NODE_ENV !== 'production') 
        verifyPlainObject(props, displayName, methodName)
      //返回一个纯对象
      return props
    }

    return proxy
  }
}
